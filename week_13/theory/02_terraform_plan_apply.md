# Terraform Plan & Apply

## ğŸ¯ Terraform Workflow

```
Write Config â†’ Init â†’ Plan â†’ Apply â†’ Destroy
   (.tf)        â†“      â†“      â†“        â†“
              Download Review Execute  Cleanup
              Providers Changes Resources
```

---

## ğŸ“Š Core Commands

### 1. terraform init

**Initializes working directory**

```bash
terraform init
```

**What it does:**
- Downloads provider plugins (AWS, Azure, etc.)
- Initializes backend (S3, local, etc.)
- Downloads modules
- Creates `.terraform/` directory

**Output:**
```
Initializing the backend...
Initializing provider plugins...
- Installing hashicorp/aws v5.0.0...

Terraform has been successfully initialized!
```

**When to run:**
- First time in directory
- After adding new providers
- After changing backend configuration

---

### 2. terraform plan

**Shows what will change**

```bash
terraform plan
```

**What it does:**
- Reads current state
- Compares with config
- Shows diff (what will be created/modified/destroyed)
- Does NOT make changes

**Output:**
```
Terraform will perform the following actions:

  # aws_lambda_function.processor will be created
  + resource "aws_lambda_function" "processor" {
      + arn           = (known after apply)
      + function_name = "my-processor"
      + memory_size   = 1024
      + runtime       = "provided.al2023"
    }

Plan: 1 to add, 0 to change, 0 to destroy.
```

**Symbols:**
- `+` = Create
- `~` = Update in-place
- `-` = Destroy
- `-/+` = Destroy and recreate
- `<=` = Read (data source)

---

### 3. terraform apply

**Creates/updates resources**

```bash
terraform apply
```

**What it does:**
1. Runs `plan` automatically
2. Shows changes
3. Asks for confirmation: `yes`
4. Executes changes
5. Updates state

**Output:**
```
Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only 'yes' will be accepted to approve.

  Enter a value: yes

aws_lambda_function.processor: Creating...
aws_lambda_function.processor: Creation complete after 5s

Apply complete! Resources: 1 added, 0 changed, 0 destroyed.
```

**Auto-approve (âš ï¸ dangerous):**
```bash
terraform apply -auto-approve
```

---

### 4. terraform destroy

**Deletes all resources**

```bash
terraform destroy
```

**What it does:**
- Shows what will be destroyed
- Asks for confirmation
- Deletes resources from AWS
- Updates state (removes resources)

**Output:**
```
Plan: 0 to add, 0 to change, 5 to destroy.

Do you really want to destroy all resources?
  Enter a value: yes

aws_lambda_function.processor: Destroying...
aws_lambda_function.processor: Destruction complete

Destroy complete! Resources: 5 destroyed.
```

---

## ğŸ¯ Plan Details

### Plan Output Analysis

```hcl
# Example plan output

# Create new resource
+ resource "aws_lambda_function" "processor" {
    + arn           = (known after apply)
    + function_name = "processor"
    + memory_size   = 1024
  }

# Update existing resource
~ resource "aws_lambda_function" "processor" {
    id            = "processor"
  ~ memory_size   = 512 -> 1024
  ~ timeout       = 30 -> 60
}

# Destroy and recreate (can't update in-place)
-/+ resource "aws_lambda_function" "processor" {
    - runtime     = "go1.x"
    + runtime     = "provided.al2023"
  }

# Destroy resource
- resource "aws_lambda_function" "processor" {
    - arn = "arn:aws:lambda:us-east-1:123:function:processor"
  }
```

### Known After Apply

```hcl
+ resource "aws_lambda_function" "processor" {
    + arn = (known after apply)  # Generated by AWS
    + id  = (known after apply)  # Generated by AWS
  }
```

**Why?** AWS generates these values, Terraform doesn't know them yet.

---

## ğŸ”„ Change Types

### 1. In-Place Update (Safe)

```hcl
# Before
memory_size = 512

# After
memory_size = 1024

# Plan shows:
~ memory_size = 512 -> 1024
```

**Result:** Resource updated without recreation

### 2. Recreate (âš ï¸ Downtime)

```hcl
# Before
runtime = "go1.x"

# After
runtime = "provided.al2023"

# Plan shows:
-/+ (destroy and recreate)
```

**Result:** Resource deleted then created (downtime!)

### 3. Forced Recreation

```hcl
resource "aws_lambda_function" "processor" {
  # Force replacement on next apply
  lifecycle {
    create_before_destroy = true
  }
}
```

---

## ğŸ“ Plan Options

### Save Plan

```bash
# Save plan to file
terraform plan -out=tfplan

# Apply saved plan (no confirmation needed)
terraform apply tfplan
```

**Use case:** CI/CD pipelines

### Target Specific Resources

```bash
# Plan only for Lambda
terraform plan -target=aws_lambda_function.processor

# Apply only Lambda
terraform apply -target=aws_lambda_function.processor
```

**âš ï¸ Warning:** Can break dependencies, use carefully!

### Refresh State Before Plan

```bash
# Update state from real resources, then plan
terraform plan -refresh-only
```

---

## ğŸ¯ Apply Options

### Auto-Approve

```bash
terraform apply -auto-approve
```

**âš ï¸ Use only in:**
- CI/CD pipelines
- Scripts
- Non-production
- When you're 100% sure

### Replace Specific Resource

```bash
# Force recreation
terraform apply -replace=aws_lambda_function.processor
```

### Parallelism

```bash
# Control concurrent resource operations (default 10)
terraform apply -parallelism=5
```

---

## ğŸ” Other Useful Commands

### terraform show

```bash
# Show current state
terraform show

# Show specific plan
terraform show tfplan
```

### terraform output

```bash
# Show all outputs
terraform output

# Show specific output
terraform output lambda_arn
```

### terraform fmt

```bash
# Format .tf files
terraform fmt

# Check if formatted
terraform fmt -check

# Recursive
terraform fmt -recursive
```

### terraform validate

```bash
# Validate configuration syntax
terraform validate
```

### terraform graph

```bash
# Generate dependency graph (DOT format)
terraform graph | dot -Tpng > graph.png
```

---

## ğŸ¯ Typical Workflow

### Development

```bash
# 1. Write config (main.tf)
vim main.tf

# 2. Initialize
terraform init

# 3. Validate syntax
terraform validate

# 4. Format code
terraform fmt

# 5. Plan changes
terraform plan

# 6. Review plan carefully

# 7. Apply
terraform apply

# 8. Verify in AWS Console

# 9. If needed, make changes and repeat
```

### Production Deployment

```bash
# 1. Pull latest code
git pull

# 2. Initialize (if needed)
terraform init

# 3. Plan and save
terraform plan -out=prod.tfplan

# 4. Review plan file
terraform show prod.tfplan

# 5. Get approval (manual/automated)

# 6. Apply saved plan
terraform apply prod.tfplan

# 7. Verify deployment

# 8. Tag release
git tag -a v1.0.0 -m "Production deployment"
```

---

## âš ï¸ Common Mistakes

### Mistake 1: Not Running Plan

```bash
# âŒ BAD
terraform apply -auto-approve

# âœ… GOOD
terraform plan    # Review first!
terraform apply
```

### Mistake 2: Using `-target` Too Often

```bash
# âŒ BAD (breaks dependencies)
terraform apply -target=aws_lambda_function.processor

# âœ… GOOD (apply all)
terraform apply
```

### Mistake 3: Not Saving Plan in CI/CD

```bash
# âŒ BAD (plan and apply different)
terraform plan
# ... time passes ...
terraform apply  # Different state!

# âœ… GOOD (use saved plan)
terraform plan -out=tfplan
terraform apply tfplan
```

---

## ğŸ“ Ğ’Ğ¸ÑĞ½Ğ¾Ğ²Ğ¾Ğº

### Terraform Workflow:

âœ… **init** - Download providers  
âœ… **plan** - Preview changes  
âœ… **apply** - Execute changes  
âœ… **destroy** - Cleanup resources  

### Key Points:

1. **Always run plan** before apply
2. **Review changes** carefully
3. **Save plan** for CI/CD
4. **Format code** with `terraform fmt`
5. **Validate** with `terraform validate`

### Golden Rule:

**"Plan carefully, apply confidently!"**

---

## ğŸ“– Ğ”Ğ°Ğ»Ñ–

- `practice/01_lambda_terraform/` - Lambda infrastructure
- `practice/02_sqs_terraform/` - SQS + DLQ
- `practice/03_iam_terraform/` - IAM roles

**"Infrastructure as Code = Reproducible, Versionable, Auditable!" ğŸ—ï¸**
